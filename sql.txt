***** SQL. 4. DDL & DML
*****
CREATE DATABASE company_repository;

CREATE SCHEMA  company_storage;

DROP SCHEMA company_storage;
*****
***** SQL. 5. Создание таблиц
*****
CREATE TABLE company_storage.company (
    id INT,
    name VARCHAR(128),
    data DATE
);

-- DROP TABLE public.company;
*****
***** SQL. 6. Операция Insert. Constraints
CREATE TABLE company_storage.company
(
    id   INT PRIMARY KEY,
    name VARCHAR(128) UNIQUE NOT NULL,
    data DATE NOT NULL CHECK (data > '1995-01-01' AND data < '2020-01-01')
    -- PRIMARY KEY (id),
    -- UNIQUE (name)
    -- UNIQUE
    -- CHECK
    -- PRIMARY KEY = UNIQUE NOT NULL
    -- FOREIGN KEY
);

INSERT INTO company(id, name, data)
VALUES (1, 'Google', '2001-01-01'),
       (2, 'Apple', '2002-10-29'),
       (3, 'Facebook', '1998-09-13');
*****
***** SQL. 7. Автогенерируемые идентификаторы
CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,
    first_name VARCHAR(128) NOT NULL,
    last_name  VARCHAR(128) NOT NULL,
    salary     INT,
    UNIQUE (first_name, last_name)
);

-- DROP TABLE employee;

insert into employee (first_name, last_name, salary)
values ('Ivan', 'Ivanov', 1000),
       ('Petr', 'Petrov', 2000),
       ('Sveta', 'Svetikova', 1500);
*****
***** SQL. 8. Создание запросов - SELECT. Сортировка выборки - ORDER BY
*****
-- Alias (псевдонимы) для полей и таблиц.
-- DISTINCT - дублирующиеся данные убираются.
-- OFFSET 2 - пробустить 2 записи.
-- LIMIT 2 - отобразить только 2 записи.
-- ORDER BY salary ASC - сортирует по возрастанию.
-- ORDER BY salary DESC - сортирует по убыванию.
SELECT DISTINCT
       id,
       first_name f_name,
       last_name l_name,
       salary
FROM employee empl
ORDER BY salary DESC
LIMIT 2
OFFSET 2;
*****
***** SQL. 9. Фильтрация выборки - WHERE
*****
SELECT DISTINCT id,
                first_name f_name,
                last_name  l_name,
                salary
FROM employee empl
-- WHERE salary > 1200
-- WHERE first_name = 'Ivan'
-- WHERE first_name LIKE 'Pet%'
-- WHERE last_name LIKE '%ov%'
-- WHERE first_name ILIKE 'ivan'
-- WHERE salary BETWEEN 1000 AND 1500
-- WHERE salary IN (1000, 1100, 2000)
--WHERE salary IN (1000, 1100, 2000) AND first_name LIKE 'Iv%'
-- У AND приоритет выше чем у OR.
WHERE salary IN (1000, 1100, 2000)
   OR (first_name LIKE 'Iv%'
    AND last_name ILIKE '%ov%')
ORDER BY salary DESC;
--LIMIT 2
--OFFSET 2;
*****
***** SQL. 10. Агрегирующие и встроенные функции
*****
SELECT
       -- sum(salary) -- Вся сумма.
       -- avg(salary) -- Средняя сумма.
       -- max(salary) -- Максимальная сумма.
       -- min(salary) -- Минимальная сумма.
       -- count(salary) -- Кол-во строк в нашей выборке.
       -- count(*) -- Кол-во строк в нашей выборке.
       -- upper(first_name) -- Приводит наше поле в верхний регистр.
       -- lower(first_name) -- Приводит наше поле в нижний регистр.
       -- concat(first_name, ' ', last_name, ' ', salary) -- Объединяет все строки перечисленные.
       -- concat(first_name, ' ', last_name, ' ', salary) fio -- Объединяет все строки перечисленные.

FROM employee empl;

SELECT now()
*****
***** SQL. 11. Внешний ключ - FOREIGN KEY
*****
CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,
    first_name VARCHAR(128) NOT NULL,
    last_name  VARCHAR(128) NOT NULL,
    company_id INT REFERENCES company (id),
    salary     INT,
    UNIQUE (first_name, last_name)
   -- FOREIGN KEY (company_id) REFERENCES company (id)
);

 DROP TABLE employee;

insert into employee (first_name, last_name, salary, company_id)
values ('Ivan', 'Sidorov', 500, 1),
       ('Ivan', 'Ivanov', 1000, 2),
       ('Arni', 'Paramonov', NULL, 2),
       ('Petr', 'Petrov', 2000, 3),
       ('Sveta', 'Svetikova', 1500, NULL);
*****
***** SQL. 12. Объединение запросов - UNION
*****
SELECT
    id,first_name
FROM employee
WHERE company_id IS NOT NULL
UNION
SELECT
    id, first_name
FROM employee
WHERE salary IS NULL;

-- Для удаления дубликатов из одного SELECT
-- можно использовать ключевое слово DISTINCT.
*****
***** SQL. 13. Подзапросы
*****
SELECT
       avg(empl.salary)
FROM (SELECT
          *
      FROM employee
      ORDER BY salary DESC
      LIMIT 2) empl;

select *,
       (select avg(salary) from employee) avg,
       (select max(salary) from employee) max,
       (select max(salary) from employee) - salary diff
from employee;

select *
from employee
-- where company_id IN (1, 2);
where company_id IN (select company.id from company);

SELECT
       *
FROM employee
ORDER BY salary
LIMIT 2;
*****
***** SQL. 14. Удаление строк - DELETE
*****

CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,
    first_name VARCHAR(128) NOT NULL,
    last_name  VARCHAR(128) NOT NULL,
    -- company_id INT REFERENCES company (id) ON DELETE
    -- ON DELETE CASCADE > Если мы удаляем компанию то и удаляем
    -- всего сотрудников в ней. Что бы не удалять сотрудника
    -- перед тем как удаляем компанию.
    company_id INT REFERENCES company (id) ON DELETE CASCADE ,
    salary     INT,
    UNIQUE (first_name, last_name)
   -- FOREIGN KEY (company_id) REFERENCES company (id)
);

 DROP TABLE employee;

insert into employee (first_name, last_name, salary, company_id)
values ('Ivan', 'Sidorov', 500, 1),
       ('Ivan', 'Ivanov', 1000, 2),
       ('Arni', 'Paramonov', NULL, 2),
       ('Petr', 'Petrov', 2000, 3),
       ('Sveta', 'Svetikova', 1500, NULL);


       DELETE FROM employee
       WHERE salary IS NULL;

       DELETE
       FROM employee
       WHERE salary = (SELECT max(salary) FROM employee);

       -- Сначала удаляем id компании.
       DELETE
       FROM employee
       WHERE company_id = 1;

       -- После только можно удалить саму компанию.
       DELETE
       FROM company
       WHERE id = 2;


       select *
       from employee;
*****
***** SQL. 15. Обновление строк - UPDATE
*****
UPDATE employee
SET company_id = 1,
    salary     = 1700
WHERE id = 10 OR id = 9
RETURNING id, first_name || ' ' || employee.last_name fio;
*****
***** SQL. 17. Нормализация баз данных. Теория
*****
*****
***** SQL. 18. Нормальные формы. 1НФ, 2НФ, 3НФ
*****
*****
***** SQL. 19. Связи между таблицами
*****
*****
***** SQL. 20. Соединение таблиц. INNER & CROSS JOIN
*****
SELECT company.name,
       employee.first_name || employee.last_name fio
FROM employee,
     company
WHERE employee.company_id = company.id;

SELECT c.name,
       employee.first_name || employee.last_name fio
FROM employee
         INNER JOIN company c ON employee.company_id = c.id;

-- INNER JOIN
-- CROSS JOIN
-- LEFT OUTER JOIN
-- RIGHT OUTER JOIN
-- FULL OUTER JOIN
-- **************
-- JOIN
-- CROSS JOIN
-- LEFT JOIN
-- RIGHT JOIN
-- FULL JOIN
*****
***** SQL. 21. Соединение таблиц. OUTER JOINs. LEFT, RIGHT, FULL
*****
CREATE TABLE contact
(
    id     SERIAL PRIMARY KEY,
    number VARCHAR(128) NOT NULL,
    type   VARCHAR(128)
);

insert into contact (number, type)
values ('234-56-78', 'домашний'),
       ('987-65-43', 'рабочий'),
       ('345-12-49', 'мобильный'),
       ('123-76-00', ''),
       ('223-47-81', '');

CREATE TABLE employee_contact
(
    employee_id INT NOT NULL REFERENCES employee (id) ON DELETE CASCADE,
    contact_id  INT NOT NULL REFERENCES contact (id) ON DELETE CASCADE

);

drop table employee_contact;

insert into employee_contact (employee_id, contact_id)
values (1, 1),
       (1, 2),
       (2, 2),
       (2, 3),
       (2, 4),
       (3, 5);
-- ****

SELECT c.name,
       e.first_name
FROM company c
         LEFT JOIN employee e
                   ON c.id = e.company_id;

SELECT c.name,
       e.first_name
FROM employee e
         LEFT JOIN company c ON e.company_id = c.id;


SELECT c.name,
       e.first_name
FROM employee e
         RIGHT JOIN company c
             ON e.company_id = c.id
             AND c.data > '2001-01-01';

SELECT c.name,
       e.first_name
FROM employee e
         FULL JOIN company c
                    ON e.company_id = c.id;
*****
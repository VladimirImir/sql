***** SQL. 4. DDL & DML
*****
CREATE DATABASE company_repository;

CREATE SCHEMA  company_storage;

DROP SCHEMA company_storage;
*****
***** SQL. 5. Создание таблиц
*****
CREATE TABLE company_storage.company (
    id INT,
    name VARCHAR(128),
    data DATE
);

-- DROP TABLE public.company;
*****
***** SQL. 6. Операция Insert. Constraints
CREATE TABLE company_storage.company
(
    id   INT PRIMARY KEY,
    name VARCHAR(128) UNIQUE NOT NULL,
    data DATE NOT NULL CHECK (data > '1995-01-01' AND data < '2020-01-01')
    -- PRIMARY KEY (id),
    -- UNIQUE (name)
    -- UNIQUE
    -- CHECK
    -- PRIMARY KEY = UNIQUE NOT NULL
    -- FOREIGN KEY
);

INSERT INTO company(id, name, data)
VALUES (1, 'Google', '2001-01-01'),
       (2, 'Apple', '2002-10-29'),
       (3, 'Facebook', '1998-09-13');
*****
***** SQL. 7. Автогенерируемые идентификаторы
CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,
    first_name VARCHAR(128) NOT NULL,
    last_name  VARCHAR(128) NOT NULL,
    salary     INT,
    UNIQUE (first_name, last_name)
);

-- DROP TABLE employee;

insert into employee (first_name, last_name, salary)
values ('Ivan', 'Ivanov', 1000),
       ('Petr', 'Petrov', 2000),
       ('Sveta', 'Svetikova', 1500);
*****
***** SQL. 8. Создание запросов - SELECT. Сортировка выборки - ORDER BY
*****
-- Alias (псевдонимы) для полей и таблиц.
-- DISTINCT - дублирующиеся данные убираются.
-- OFFSET 2 - пробустить 2 записи.
-- LIMIT 2 - отобразить только 2 записи.
-- ORDER BY salary ASC - сортирует по возрастанию.
-- ORDER BY salary DESC - сортирует по убыванию.
SELECT DISTINCT
       id,
       first_name f_name,
       last_name l_name,
       salary
FROM employee empl
ORDER BY salary DESC
LIMIT 2
OFFSET 2;
*****
***** SQL. 9. Фильтрация выборки - WHERE
*****
SELECT DISTINCT id,
                first_name f_name,
                last_name  l_name,
                salary
FROM employee empl
-- WHERE salary > 1200
-- WHERE first_name = 'Ivan'
-- WHERE first_name LIKE 'Pet%'
-- WHERE last_name LIKE '%ov%'
-- WHERE first_name ILIKE 'ivan'
-- WHERE salary BETWEEN 1000 AND 1500
-- WHERE salary IN (1000, 1100, 2000)
--WHERE salary IN (1000, 1100, 2000) AND first_name LIKE 'Iv%'
-- У AND приоритет выше чем у OR.
WHERE salary IN (1000, 1100, 2000)
   OR (first_name LIKE 'Iv%'
    AND last_name ILIKE '%ov%')
ORDER BY salary DESC;
--LIMIT 2
--OFFSET 2;
*****
***** SQL. 10. Агрегирующие и встроенные функции
*****
SELECT
       -- sum(salary) -- Вся сумма.
       -- avg(salary) -- Средняя сумма.
       -- max(salary) -- Максимальная сумма.
       -- min(salary) -- Минимальная сумма.
       -- count(salary) -- Кол-во строк в нашей выборке.
       -- count(*) -- Кол-во строк в нашей выборке.
       -- upper(first_name) -- Приводит наше поле в верхний регистр.
       -- lower(first_name) -- Приводит наше поле в нижний регистр.
       -- concat(first_name, ' ', last_name, ' ', salary) -- Объединяет все строки перечисленные.
       -- concat(first_name, ' ', last_name, ' ', salary) fio -- Объединяет все строки перечисленные.

FROM employee empl;

SELECT now()
*****
***** SQL. 11. Внешний ключ - FOREIGN KEY
*****
CREATE TABLE employee
(
    id         SERIAL PRIMARY KEY,
    first_name VARCHAR(128) NOT NULL,
    last_name  VARCHAR(128) NOT NULL,
    company_id INT REFERENCES company (id),
    salary     INT,
    UNIQUE (first_name, last_name)
   -- FOREIGN KEY (company_id) REFERENCES company (id)
);

 DROP TABLE employee;

insert into employee (first_name, last_name, salary, company_id)
values ('Ivan', 'Sidorov', 500, 1),
       ('Ivan', 'Ivanov', 1000, 2),
       ('Arni', 'Paramonov', NULL, 2),
       ('Petr', 'Petrov', 2000, 3),
       ('Sveta', 'Svetikova', 1500, NULL);
*****
***** SQL. 12. Объединение запросов - UNION
*****
SELECT
    id,first_name
FROM employee
WHERE company_id IS NOT NULL
UNION
SELECT
    id, first_name
FROM employee
WHERE salary IS NULL;

-- Для удаления дубликатов из одного SELECT
-- можно использовать ключевое слово DISTINCT.
*****
***** SQL. 13. Подзапросы
*****
SELECT
       avg(empl.salary)
FROM (SELECT
          *
      FROM employee
      ORDER BY salary DESC
      LIMIT 2) empl;

select *,
       (select avg(salary) from employee) avg,
       (select max(salary) from employee) max,
       (select max(salary) from employee) - salary diff
from employee;

select *
from employee
-- where company_id IN (1, 2);
where company_id IN (select company.id from company);

SELECT
       *
FROM employee
ORDER BY salary
LIMIT 2;
*****
*****
*****